'use client';

import { useCallback, useEffect, useMemo } from 'react';
import { usePersistentState } from './usePersistentState';
import { useInventory } from './useInventory';
import {
  type CalendarEvent,
  type EventType,
  cloneDefaultEvents,
  generateEventId,
  isSameDay,
  normaliseDate,
  normaliseEvent,
  sortByDate,
  eventsToICS,
  icsToEvents,
} from '../lib/events';

type EventStreakState = {
  streak: number;
  lastDate: string | null;
  totalCompletions: number;
};

type IcsImportResult = {
  imported: number;
  skipped: number;
};

type CalendarToggles = {
  autoDailyRitual: boolean;
  autoPantyReset: boolean;
};

const CALENDAR_TOGGLES_KEY = 'eventsToggles';
const CALENDAR_STREAK_KEY = 'eventsStreak';
const CALENDAR_ACHIEVEMENTS_KEY = 'eventAchievements';

const DEFAULT_TOGGLES: CalendarToggles = {
  autoDailyRitual: true,
  autoPantyReset: true,
};

export function useEvents() {
  const [events, setEvents] = usePersistentState<CalendarEvent[]>('events', cloneDefaultEvents);
  const [toggles, setToggles] = usePersistentState<CalendarToggles>(CALENDAR_TOGGLES_KEY, () => DEFAULT_TOGGLES);
  const [streakState, setStreakState] = usePersistentState<EventStreakState>(CALENDAR_STREAK_KEY, () => ({
    streak: 0,
    lastDate: null,
    totalCompletions: 0,
  }));
  const [achievements, setAchievements] = usePersistentState<string[]>(CALENDAR_ACHIEVEMENTS_KEY, () => []);

  const { awardXp, awardObedience, awardTokens } = useInventory();

  const setSafe = useCallback(
    (updater: (previous: CalendarEvent[]) => CalendarEvent[]) => {
      setEvents((previous) => sortByDate(updater(previous).map((event) => normaliseEvent(event))));
    },
    [setEvents]
  );

  const addEvent = useCallback(
    (event: CalendarEvent) => {
      setSafe((previous) => [...previous, event]);
    },
    [setSafe]
  );

  const updateEvent = useCallback(
    (eventId: string, updater: (event: CalendarEvent) => CalendarEvent) => {
      setSafe((previous) =>
        previous.map((entry) => (entry.id === eventId ? updater({ ...entry }) : entry))
      );
    },
    [setSafe]
  );

  const removeEvent = useCallback(
    (eventId: string) => {
      setSafe((previous) => previous.filter((event) => event.id !== eventId));
    },
    [setSafe]
  );

  const deleteAllEvents = useCallback(() => {
    setSafe(() => []);
  }, [setSafe]);

  const importFromIcs = useCallback(
    (payload: string): IcsImportResult => {
      if (!payload || payload.trim().length === 0) {
        return { imported: 0, skipped: 0 };
      }

      const parsed = icsToEvents(payload);
      if (parsed.length === 0) {
        return { imported: 0, skipped: 0 };
      }

      let imported = 0;
      let skipped = 0;

      setSafe((previous) => {
        const knownIds = new Set(previous.map((event) => event.id));
        const knownKeys = new Set(
          previous.map((event) => event.date + '|' + event.title).join(', ').toLowerCase()
        );
        const next = [...previous];

        parsed.forEach((raw) => {
          const normalized = normaliseEvent({
            ...raw,
            source: raw.source ?? 'imported',
          });

          const key = (normalized.date + '|' + normalized.title).toLowerCase();
          if (knownKeys.has(key)) {
            skipped += 1;
            return;
          }

          let identifier = normalized.id;
          if (knownIds.has(identifier)) {
            identifier = generateEventId('import');
            skipped += 1;
          }

          knownIds.add(identifier);
          knownKeys.add(key);
          next.push({ ...normalized, id: identifier });
          imported += 1;
        });

        return next;
      });

      return { imported, skipped };
    },
    [setSafe]
  );

  // Rest of the code...